"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var src_exports = {};
__export(src_exports, {
  HashType: () => HashType,
  StarknetMerkleTree: () => StarknetMerkleTree,
  computePoseidonHashOnElements: () => computePoseidonHashOnElements,
  hashDataToBigint: () => hashDataToBigint,
  hashDataToHex: () => hashDataToHex,
  hashPair: () => hashPair
});
module.exports = __toCommonJS(src_exports);
var import_starknet = require("starknet");
var HashType = /* @__PURE__ */ ((HashType2) => {
  HashType2["Pedersen"] = "Pedersen";
  HashType2["Poseidon"] = "Poseidon";
  return HashType2;
})(HashType || {});
function throwError(message) {
  throw new Error(message);
}
var leftChildIndex = (i) => 2 * i + 1;
var rightChildIndex = (i) => 2 * i + 2;
var hashPair = (a, b, hashType = "Pedersen" /* Pedersen */) => BigInt(a) - BigInt(b) >= 0n ? import_starknet.num.toBigInt(hashType == "Pedersen" /* Pedersen */ ? import_starknet.ec.starkCurve.pedersen(b, a) : import_starknet.ec.starkCurve.poseidonHashMany([b, a])) : import_starknet.num.toBigInt(hashType == "Pedersen" /* Pedersen */ ? import_starknet.ec.starkCurve.pedersen(a, b) : import_starknet.ec.starkCurve.poseidonHashMany([a, b]));
function computePoseidonHashOnElements(data) {
  const dataBigint = data.map((val) => BigInt(val));
  return import_starknet.ec.starkCurve.poseidonHashMany([0n, ...dataBigint, BigInt(dataBigint.length)]);
}
function hashDataToHex(data, hashType = "Pedersen" /* Pedersen */) {
  let aa = [];
  if (Array.isArray(data)) {
    aa = data;
  } else {
    aa.push(data);
  }
  return import_starknet.encode.addHexPrefix(hashType == "Pedersen" /* Pedersen */ ? import_starknet.ec.starkCurve.computeHashOnElements(aa).toString(16) : computePoseidonHashOnElements(aa).toString(16));
}
function hashDataToBigint(data, hashType = "Pedersen" /* Pedersen */) {
  let aa = [];
  if (Array.isArray(data)) {
    aa = data;
  } else {
    aa.push(data);
  }
  return hashType == "Pedersen" /* Pedersen */ ? BigInt(import_starknet.ec.starkCurve.computeHashOnElements(aa)) : computePoseidonHashOnElements(aa);
}
function makeMerkleTree(leaves, hashType = "Pedersen" /* Pedersen */) {
  if (leaves.length === 0) {
    throw new Error("Expected non-zero number of leaves");
  }
  const tree = new Array(2 * leaves.length - 1);
  for (const [i, leaf] of leaves.entries()) {
    tree[tree.length - 1 - i] = leaf;
  }
  for (let i = tree.length - 1 - leaves.length; i >= 0; i -= 1) {
    tree[i] = hashPair(tree[leftChildIndex(i)], tree[rightChildIndex(i)], hashType);
  }
  return tree;
}
function isValidMerkleTree(tree, hashType = "Pedersen" /* Pedersen */) {
  for (const [i, node] of tree.entries()) {
    const l = leftChildIndex(i);
    const r = rightChildIndex(i);
    if (r >= tree.length) {
      if (l < tree.length) {
        return false;
      }
    } else if (!(node === hashPair(tree[l], tree[r]), hashType)) {
      return false;
    }
  }
  return tree.length > 0;
}
var isTreeNode = (tree, i) => i >= 0 && i < tree.length;
var isInternalNode = (tree, i) => isTreeNode(tree, leftChildIndex(i));
var isLeafNode = (tree, i) => isTreeNode(tree, i) && !isInternalNode(tree, i);
var checkLeafNode = (tree, i) => isLeafNode(tree, i) || throwError("Index is not a leaf");
var parentIndex = (i) => i > 0 ? Math.floor((i - 1) / 2) : throwError("Root has no parent");
var siblingIndex = (i) => i > 0 ? i - (-1) ** (i % 2) : throwError("Root has no siblings");
function getProof(tree, index) {
  checkLeafNode(tree, index);
  let idx = index;
  const proof = [];
  while (idx > 0) {
    proof.push(tree[siblingIndex(idx)]);
    idx = parentIndex(idx);
  }
  return proof;
}
function biToHex(b) {
  return import_starknet.encode.addHexPrefix(b.toString(16));
}
function processProof(leaf, proof, hashType) {
  return proof.reduce((x, y) => hashPair(x, y, hashType), leaf);
}
function renderMerkleTree(tree) {
  if (tree.length === 0) {
    throw new Error("Expected non-zero number of nodes");
  }
  const stack = [[0, []]];
  const lines = [];
  while (stack.length > 0) {
    const [i, path] = stack.pop();
    lines.push(
      // eslint-disable-next-line prefer-template
      path.slice(0, -1).map((p) => ["   ", "\u2502  "][p]).join("") + path.slice(-1).map((p) => ["\u2514\u2500 ", "\u251C\u2500 "][p]).join("") + i + ") " + import_starknet.encode.addHexPrefix(tree[i].toString(16))
    );
    if (rightChildIndex(i) < tree.length) {
      stack.push([rightChildIndex(i), path.concat(0)]);
      stack.push([leftChildIndex(i), path.concat(1)]);
    }
  }
  return lines.join("\n");
}
var StarknetMerkleTree = class _StarknetMerkleTree {
  constructor(tree, values, hashLookup, hashType = "Pedersen" /* Pedersen */) {
    this.tree = tree;
    this.values = values;
    this.hashLookup = hashLookup;
    this.hashType = hashType;
  }
  static adaptInputItem(element) {
    return import_starknet.num.getHexString(element);
  }
  /**
   * Creates a standard Merkle tree out of an array.
   *
   * @param values - the content of each leaf of the tree.
   * @param hashType - the type of hash : HashType.Pedersen or HashType.Poseidon.
   *
   * @returns a Merkle tree object
   * @example
   * ```typescript
   * const data: merkle.inputForMerkle[] = [
   *   ['0x69b49c2cc8b16e80e86bfc5b0614a59aa8c9b601569c7b80dde04d3f3151b79', '256'],
   *   ['0x3cad9a072d3cf29729ab2fad2e08972b8cfde01d4979083fb6d15e8e66f8ab1', '25'],
   *   ['0x27d32a3033df4277caa9e9396100b7ca8c66a4ef8ea5f6765b91a7c17f0109c', '56'],
   *   ['0x7e00d496e324876bbc8531f2d9a82bf154d1a04a50218ee74cdd372f75a551a', '26'],
   *   ['0x53c615080d35defd55569488bc48c1a91d82f2d2ce6199463e095b4a4ead551', '56'],
   * ];
   * const tree = merkle.StarknetMerkleTree.create(data);
   * ```
   */
  static create(values, hashType = "Pedersen" /* Pedersen */) {
    const checkedValues = values.map((item) => {
      if (typeof item === "string") {
        return _StarknetMerkleTree.adaptInputItem(item);
      }
      return item.map(_StarknetMerkleTree.adaptInputItem);
    });
    const hashedValues = checkedValues.map(
      (value, valueIndex) => ({ val: value, valueInd: valueIndex, hash: hashDataToBigint(value, hashType) })
    ).sort((a, b) => a.hash - b.hash >= 0n ? 1 : -1);
    const tree = makeMerkleTree(hashedValues.map((v) => v.hash), hashType);
    const indexedValues = checkedValues.map((value) => ({ value, treeIndex: 0 }));
    for (const [leafIndex, { valueInd }] of hashedValues.entries()) {
      indexedValues[valueInd].treeIndex = tree.length - leafIndex - 1;
    }
    const mapping = checkedValues.map((value, valueIndex) => {
      return [hashDataToHex(value, hashType), valueIndex];
    });
    const hashLookup = Object.fromEntries(mapping);
    return new _StarknetMerkleTree(tree, indexedValues, hashLookup, hashType);
  }
  /**
   * return the nth data used for the tree creation.
   *
   * @param pos - input data order (0 first).
   * @returns
   * @example
   * ```typescript
   * const data= tree.getInputData(3);
   * ```
   */
  getInputData(pos) {
    return this.values[pos].value;
  }
  /**
   * Loads the tree from a description previously returned by {@link dump}.
   *
   * @param data - storage of Merkle tree.
   * @returns - a merkle tree description
   * @example
   * ```typescript
   * StarknetMerkleTree.load(JSON.parse(fs.readFileSync('tree.json','ascii')));
   * ```
   */
  static load(data) {
    if (data.format !== "standard-v2") {
      throw new Error(`Unknown format '${data.format}'`);
    }
    return new _StarknetMerkleTree(data.tree.map(BigInt), data.values, data.hashLookup, data.hashType);
  }
  /**
   * Returns a description of the merkle tree for distribution.
   * It contains all the necessary information to reproduce the tree,
   * find the relevant leaves, and generate proofs.
   * You should distribute this to users in a web application
   * so they can generate proofs for their leaves of interest.
   *
   * @returns - a merkle tree description
   * @example
   * ```typescript
   * fs.writeFileSync('tree.json', JSON.stringify(tree.dump(),undefined,2));
   * ```
   */
  dump() {
    return {
      format: "standard-v2",
      tree: this.tree.map(biToHex),
      values: this.values,
      hashLookup: this.hashLookup,
      hashType: this.hashType == "Pedersen" /* Pedersen */ ? "Pedersen" /* Pedersen */ : "Poseidon" /* Poseidon */
    };
  }
  /**
   * Returns a visual representation of the tree that can be useful for debugging.
   *
   * @returns string containing the result.
   * @example
   * ```typescript
   * console.log(tree.render());
   * ```
   */
  render() {
    return renderMerkleTree(this.tree);
  }
  /**
   * The root of the tree is a commitment on the values of the tree. It can be
   * published in a smart contract, to later prove that its values are part
   * of the tree.
   *
   * @returns an HexString ("0x1e3")
   * @example
   * ```typescript
   * console.log(tree.root);
   * ```
   */
  get root() {
    return import_starknet.encode.addHexPrefix(this.tree[0].toString(16));
  }
  /**
   * Lists the values in the tree along with their indices,
   * which can be used to obtain proofs.
   *
   * @example
   * ```typescript
   * for (const [i, v] of tree.entries()) {
   * console.log('value:', v);
   * console.log('proof:', tree.getProof(i));
   * }
   * ```
   */
  *entries() {
    for (const [i, { value }] of this.values.entries()) {
      yield [i, value];
    }
  }
  /**
   * Verify the consistency of the tree. Useful after a load().
   * Take care that this method is time-consuming.
   * Throw an error if validation fail.
   * @example
   * ```typescript
   * tree.validate();
   * ```
   */
  validate() {
    for (let i = 0; i < this.values.length; i += 1) {
      this.validateValue(i);
    }
    if (!isValidMerkleTree(this.tree, this.hashType)) {
      throw new Error("Merkle tree is invalid");
    }
  }
  /**
   * Returns the leaf hash of the value.
   *
   * @param leaf - the data contained in a leaf.
   * @param hashType - The type of hash : HashType.Pedersen or HashType.Poseidon.
   * @returns the hash of these data, stored at the base of the tree.
   * @example
   * ```typescript
   * const leaf = merkle.leafHash(["0x1e6f3", '100'], HashType.Pedersen);
   * }
   * ```
   */
  static leafHash(leaf, hashType) {
    if (typeof leaf === "string") {
      return hashDataToHex(_StarknetMerkleTree.adaptInputItem(leaf), hashType);
    }
    const adaptedLeaf = leaf.map(_StarknetMerkleTree.adaptInputItem);
    return hashDataToHex(adaptedLeaf, hashType);
  }
  leafLookup(leaf) {
    return this.hashLookup[_StarknetMerkleTree.leafHash(leaf, this.hashType)] ?? throwError(`'This leaf is not in tree': ${leaf}`);
  }
  /**
   * Returns a proof for the ith value in the tree. Indices refer to
   * the position of the values in the array from which the tree was constructed.
   * Also accepts a value instead of an index, but this will be less efficient.
   * It will fail if the value is not found in the tree.
   *
   * @param leaf - the position of construction, or the data contained in a leaf.
   * @returns the proof, to provide to the smart-contract.
   * @example
   * ```typescript
   * const proof = tree.getProof(3);
   * const proof = tree.getProof(["0x43af5", '100']);
   * }
   * ```
   */
  getProof(leaf) {
    const valueIndex = typeof leaf === "number" ? leaf : this.leafLookup(leaf);
    this.validateValue(valueIndex);
    const { treeIndex } = this.values[valueIndex];
    const proof = getProof(this.tree, treeIndex);
    if (!this.internVerify(this.tree[treeIndex], proof)) {
      throw new Error("Unable to prove value");
    }
    return proof.map(biToHex);
  }
  /**
   * Returns a boolean that is `true` when the proof verifies that
   * the value is contained in the tree.
   * @remarks
   * This job is normally made by the smart-contract.
   * Present here just to be able to check in the DAPP.
   *
   * @param leaf - the position of construction, or the data contained in a leaf.
   * @param proof - proof obtained with {@link getProof}.
   * @returns verification that the leaf is present in the tree,
   * without using the tree content.
   * @example
   * ```typescript
   * const result = tree.verify(3, proof);
   * const result = tree.verify(["0x34e67d", '100'], proof);
   * ```
   */
  verify(leaf, proof) {
    const adaptedProof = proof.map(_StarknetMerkleTree.adaptInputItem);
    return this.internVerify(this.getLeafHash(leaf), adaptedProof.map(BigInt));
  }
  internVerify(leafHash, proof) {
    const impliedRoot = processProof(leafHash, proof, this.hashType);
    return impliedRoot === this.tree[0];
  }
  checkBounds(array, index) {
    if (index < 0 || index >= array.length) {
      throw new Error("Index out of bounds");
    }
  }
  validateValue(valueIndex) {
    this.checkBounds(this.values, valueIndex);
    const { value, treeIndex } = this.values[valueIndex];
    this.checkBounds(this.tree, treeIndex);
    const leafHash = hashDataToBigint(value, this.hashType);
    if (!(leafHash === this.tree[treeIndex])) {
      throw new Error("Merkle tree does not contain the expected value");
    }
    return leafHash;
  }
  getLeafHash(leaf) {
    if (typeof leaf === "number") {
      return this.validateValue(leaf);
    }
    if (typeof leaf === "string") {
      return hashDataToBigint(_StarknetMerkleTree.adaptInputItem(leaf), this.hashType);
    }
    const adaptedLeaf = leaf.map(_StarknetMerkleTree.adaptInputItem);
    return hashDataToBigint(adaptedLeaf, this.hashType);
  }
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  HashType,
  StarknetMerkleTree,
  computePoseidonHashOnElements,
  hashDataToBigint,
  hashDataToHex,
  hashPair
});
//# sourceMappingURL=index.js.map