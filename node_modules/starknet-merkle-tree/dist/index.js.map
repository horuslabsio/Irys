{"version":3,"sources":["../src/index.ts"],"sourcesContent":["import { ec, num, encode } from 'starknet';\n\n// ***************************************************************\n// StarknetMerkleTree, inspired by an Openzeppelin version for Ethereum, adapted for Starknet.js\n// https://github.com/OpenZeppelin/merkle-tree v1.0.2\n\n/**\n * input format for the creation of a merkle tree.\n * Strings have to be HexStrings(\"0x1a6\") or DecimalStrings(\"374\").\n */\nexport type InputForMerkle = string | string[];\n\ninterface ValueAndHash {\n  val: InputForMerkle;\n  valueInd: number;\n  hash: bigint;\n}\n\nexport enum HashType {\n  Pedersen = \"Pedersen\",\n  Poseidon = \"Poseidon\",\n}\n\n/**\n * Output format for the storage of a merkle tree.\n * Strings have to be HexStrings(\"0x1a6\") or DecimalStrings(\"374\").\n */\nexport interface StarknetMerkleTreeData {\n  /** version of the storage format */\n  format: 'standard-v2',\n  /** hash of each node of the tree */\n  tree: string[],\n  /** values of the tree leaves */\n  values: {\n    /** content of each leaf */\n    value: InputForMerkle,\n    /** position in the tree */\n    treeIndex: number,\n  }[],\n  hashLookup: { [hash: string]: number },\n  hashType: HashType,\n}\n\nfunction throwError(message?: string): never {\n  throw new Error(message);\n}\n\nconst leftChildIndex = (i: number) => 2 * i + 1;\nconst rightChildIndex = (i: number) => 2 * i + 2;\n\n/**\n * Calculate the hash of 2 values, ordered before calculation.\n *\n * @param a - first value.\n * @param b - second value.\n * @param hashType - optional. The type of hash : HashType.Pedersen (by default) or HashType.Poseidon.\n * @returns the hash of these data\n * @example\n * ```typescript\n * const hash = merkle.hasPair(34447789n, 158953n));\n * }\n * ```\n */\nexport const hashPair = (a: bigint, b: bigint, hashType: HashType = HashType.Pedersen) =>\n  BigInt(a) - BigInt(b) >= 0n\n    ? num.toBigInt(hashType == HashType.Pedersen ? ec.starkCurve.pedersen(b, a) : ec.starkCurve.poseidonHashMany([b, a]))\n    : num.toBigInt(hashType == HashType.Pedersen ? ec.starkCurve.pedersen(a, b) : ec.starkCurve.poseidonHashMany([a, b]));\n\n/**\n * Compute Poseidon hash from data\n *  @param data - Array of hex string.\n * @returns format: bigint - poseidon hash\n */\nexport function computePoseidonHashOnElements(data: string[]): bigint {\n  const dataBigint = data.map((val) => BigInt(val));\n  return ec.starkCurve.poseidonHashMany([0n,...dataBigint, BigInt(dataBigint.length)]);\n}\n\n/**\n * Calculate the hash of data formatted in {@link InputForMerkle}\n * and returns a HexString.\n *\n * @param data - array of Hex string\n * @param hashType - optional. The type of hash : HashType.Pedersen (by default) or HashType.Poseidon.\n * @returns the hash of these data in HexString format\n * @example\n * ```typescript\n * const hashHex = merkle.hashDataToHex([\"0x23a56e\",\"0x1e54\",\"0x34cc65\"]), HashType.Pedersen);\n * }\n * ```\n */\nexport function hashDataToHex(data: InputForMerkle, hashType: HashType = HashType.Pedersen): string {\n  let aa: string[] = [];\n  if (Array.isArray(data)) {\n    aa = data;\n  } else {\n    aa.push(data);\n  }\n  return encode.addHexPrefix(hashType == HashType.Pedersen ? ec.starkCurve.computeHashOnElements(aa).toString(16) : computePoseidonHashOnElements(aa).toString(16));\n}\n\n/**\n * Calculate the hash of data formatted in {@link InputForMerkle}\n * and returns a bigint.\n *\n * @param data - array of Hex string\n * @param hashType - optional. The type of hash : HashType.Pedersen (by default) or HashType.Poseidon.\n * @returns the hash of these data in bigint format\n * @example\n * ```typescript\n * const hashBigint = merkle.hashDataToBigint(\"0x23a5765C332d8f6e\"), HashType.Pedersen);\n * }\n * ```\n */\nexport function hashDataToBigint(data: InputForMerkle, hashType: HashType = HashType.Pedersen): bigint {\n  let aa: string[] = [];\n  if (Array.isArray(data)) {\n    aa = data;\n  } else {\n    aa.push(data);\n  }\n  return hashType == HashType.Pedersen ? BigInt(ec.starkCurve.computeHashOnElements(aa) as string) : computePoseidonHashOnElements(aa);\n}\n\nfunction makeMerkleTree(leaves: bigint[], hashType: HashType = HashType.Pedersen): bigint[] {\n  if (leaves.length === 0) {\n    throw new Error('Expected non-zero number of leaves');\n  }\n  const tree = new Array<bigint>(2 * leaves.length - 1);\n  // eslint-disable-next-line no-restricted-syntax\n  for (const [i, leaf] of leaves.entries()) {\n    tree[tree.length - 1 - i] = leaf;\n  }\n  for (let i = tree.length - 1 - leaves.length; i >= 0; i -= 1) {\n    tree[i] = hashPair(tree[leftChildIndex(i)], tree[rightChildIndex(i)],hashType);\n  }\n  return tree;\n}\n\nfunction isValidMerkleTree(tree: bigint[], hashType: HashType = HashType.Pedersen): boolean {\n  // eslint-disable-next-line no-restricted-syntax\n  for (const [i, node] of tree.entries()) {\n    const l = leftChildIndex(i);\n    const r = rightChildIndex(i);\n    if (r >= tree.length) {\n      if (l < tree.length) {\n        return false;\n      }\n    } else if (!(node === hashPair(tree[l], tree[r]),hashType)) {\n      return false;\n    }\n  }\n  return tree.length > 0;\n}\n\nconst isTreeNode = (tree: bigint[], i: number) => i >= 0 && i < tree.length;\nconst isInternalNode = (tree: bigint[], i: number) => isTreeNode(tree, leftChildIndex(i));\nconst isLeafNode = (tree: bigint[], i: number) => isTreeNode(tree, i) && !isInternalNode(tree, i);\nconst checkLeafNode = (tree: bigint[], i: number) =>\n  isLeafNode(tree, i) || throwError('Index is not a leaf');\nconst parentIndex = (i: number) =>\n  i > 0 ? Math.floor((i - 1) / 2) : throwError('Root has no parent');\nconst siblingIndex = (i: number) =>\n  i > 0 ? i - (-1) ** (i % 2) : throwError('Root has no siblings');\n\nfunction getProof(tree: bigint[], index: number): bigint[] {\n  checkLeafNode(tree, index);\n  // eslint-disable-next-line prefer-const\n  let idx = index;\n  const proof: bigint[] = [];\n  while (idx > 0) {\n    proof.push(tree[siblingIndex(idx)]!);\n    idx = parentIndex(idx);\n  }\n  return proof;\n}\n\nfunction biToHex(b: bigint): string {\n  return encode.addHexPrefix(b.toString(16));\n}\n\nfunction processProof(leaf: bigint, proof: bigint[], hashType: HashType): bigint {\n  return proof.reduce((x, y) => hashPair(x, y, hashType), leaf);\n}\n\nfunction renderMerkleTree(tree: bigint[]): string {\n  if (tree.length === 0) {\n    throw new Error('Expected non-zero number of nodes');\n  }\n  const stack: [number, number[]][] = [[0, []]];\n  const lines = [];\n  while (stack.length > 0) {\n    const [i, path] = stack.pop()!;\n    lines.push(\n      // eslint-disable-next-line prefer-template\n      path\n        .slice(0, -1)\n        .map((p) => ['   ', '│  '][p])\n        .join('') +\n      path\n        .slice(-1)\n        .map((p) => ['└─ ', '├─ '][p])\n        .join('') +\n      i +\n      ') ' +\n      encode.addHexPrefix(tree[i].toString(16))\n    );\n    if (rightChildIndex(i) < tree.length) {\n      stack.push([rightChildIndex(i), path.concat(0)]);\n      stack.push([leftChildIndex(i), path.concat(1)]);\n    }\n  }\n  return lines.join('\\n');\n}\n\n/**\n * Class for handling Merkle trees.\n */\nexport class StarknetMerkleTree {\n  private constructor(\n    private readonly tree: bigint[],\n    private readonly values: { value: InputForMerkle; treeIndex: number }[],\n    private readonly hashLookup: { [hash: string]: number },\n    private readonly hashType: HashType= HashType.Pedersen\n  ) { }\n\n  private static adaptInputItem(element: string): string {\n    return num.getHexString(element);\n  }\n\n  /**\n   * Creates a standard Merkle tree out of an array.\n   *\n   * @param values - the content of each leaf of the tree.\n   * @param hashType - the type of hash : HashType.Pedersen or HashType.Poseidon.\n   *\n   * @returns a Merkle tree object\n   * @example\n   * ```typescript\n   * const data: merkle.inputForMerkle[] = [\n   *   ['0x69b49c2cc8b16e80e86bfc5b0614a59aa8c9b601569c7b80dde04d3f3151b79', '256'],\n   *   ['0x3cad9a072d3cf29729ab2fad2e08972b8cfde01d4979083fb6d15e8e66f8ab1', '25'],\n   *   ['0x27d32a3033df4277caa9e9396100b7ca8c66a4ef8ea5f6765b91a7c17f0109c', '56'],\n   *   ['0x7e00d496e324876bbc8531f2d9a82bf154d1a04a50218ee74cdd372f75a551a', '26'],\n   *   ['0x53c615080d35defd55569488bc48c1a91d82f2d2ce6199463e095b4a4ead551', '56'],\n   * ];\n   * const tree = merkle.StarknetMerkleTree.create(data);\n   * ```\n   */\n  static create(values: InputForMerkle[], hashType: HashType = HashType.Pedersen): StarknetMerkleTree {\n    // verification of inputs\n    const checkedValues = values.map((item: InputForMerkle) => {\n      if (typeof item === 'string') {\n        return StarknetMerkleTree.adaptInputItem(item);\n      }\n      return item.map(StarknetMerkleTree.adaptInputItem);\n    });\n    // calculate and store\n    const hashedValues = checkedValues\n      .map(\n        (value, valueIndex) =>\n          ({ val: value, valueInd: valueIndex, hash: hashDataToBigint(value,hashType) } as ValueAndHash)\n      )\n      .sort((a, b) => (a.hash - b.hash >= 0n ? 1 : -1));\n    const tree = makeMerkleTree(hashedValues.map((v) => v.hash),hashType);\n\n    const indexedValues = checkedValues.map((value) => ({ value, treeIndex: 0 }));\n    // eslint-disable-next-line no-restricted-syntax\n    for (const [leafIndex, { valueInd }] of hashedValues.entries()) {\n      indexedValues[valueInd].treeIndex = tree.length - leafIndex - 1;\n    }\n    const mapping = checkedValues.map((value, valueIndex) => {\n      return [hashDataToHex(value,hashType), valueIndex];\n    });\n    const hashLookup = Object.fromEntries(mapping);\n    return new StarknetMerkleTree(tree, indexedValues, hashLookup, hashType);\n  }\n\n  /**\n   * return the nth data used for the tree creation.\n   *\n   * @param pos - input data order (0 first).\n   * @returns\n   * @example\n   * ```typescript\n   * const data= tree.getInputData(3);\n   * ```\n   */\n  getInputData(pos: number): InputForMerkle {\n    return this.values[pos].value;\n  }\n\n  /**\n   * Loads the tree from a description previously returned by {@link dump}.\n   *\n   * @param data - storage of Merkle tree.\n   * @returns - a merkle tree description\n   * @example\n   * ```typescript\n   * StarknetMerkleTree.load(JSON.parse(fs.readFileSync('tree.json','ascii')));\n   * ```\n   */\n  static load(data: StarknetMerkleTreeData): StarknetMerkleTree {\n    if (data.format !== 'standard-v2') {\n      throw new Error(`Unknown format '${data.format}'`);\n    }\n    return new StarknetMerkleTree(data.tree.map(BigInt), data.values, data.hashLookup, data.hashType);\n  }\n\n  /**\n   * Returns a description of the merkle tree for distribution.\n   * It contains all the necessary information to reproduce the tree,\n   * find the relevant leaves, and generate proofs.\n   * You should distribute this to users in a web application\n   * so they can generate proofs for their leaves of interest.\n   *\n   * @returns - a merkle tree description\n   * @example\n   * ```typescript\n   * fs.writeFileSync('tree.json', JSON.stringify(tree.dump(),undefined,2));\n   * ```\n   */\n  dump(): StarknetMerkleTreeData {\n    return {\n      format: 'standard-v2',\n      tree: this.tree.map(biToHex),\n      values: this.values,\n      hashLookup: this.hashLookup,\n      hashType: this.hashType==HashType.Pedersen? HashType.Pedersen:HashType.Poseidon,\n    };\n  }\n\n  /**\n   * Returns a visual representation of the tree that can be useful for debugging.\n   *\n   * @returns string containing the result.\n   * @example\n   * ```typescript\n   * console.log(tree.render());\n   * ```\n   */\n  render() {\n    return renderMerkleTree(this.tree);\n  }\n\n  /**\n   * The root of the tree is a commitment on the values of the tree. It can be\n   * published in a smart contract, to later prove that its values are part\n   * of the tree.\n   *\n   * @returns an HexString (\"0x1e3\")\n   * @example\n   * ```typescript\n   * console.log(tree.root);\n   * ```\n   */\n  get root(): string {\n    return encode.addHexPrefix(this.tree[0].toString(16));\n  }\n\n  /**\n   * Lists the values in the tree along with their indices,\n   * which can be used to obtain proofs.\n   *\n   * @example\n   * ```typescript\n   * for (const [i, v] of tree.entries()) {\n   * console.log('value:', v);\n   * console.log('proof:', tree.getProof(i));\n   * }\n   * ```\n   */\n  *entries(): Iterable<[number, InputForMerkle]> {\n    // eslint-disable-next-line no-restricted-syntax\n    for (const [i, { value }] of this.values.entries()) {\n      yield [i, value];\n    }\n  }\n\n  /**\n   * Verify the consistency of the tree. Useful after a load().\n   * Take care that this method is time-consuming.\n   * Throw an error if validation fail.\n   * @example\n   * ```typescript\n   * tree.validate();\n   * ```\n   */\n  validate() {\n    for (let i = 0; i < this.values.length; i += 1) {\n      this.validateValue(i);\n    }\n    if (!isValidMerkleTree(this.tree,this.hashType)) {\n      throw new Error('Merkle tree is invalid');\n    }\n  }\n\n  /**\n   * Returns the leaf hash of the value.\n   *\n   * @param leaf - the data contained in a leaf.\n   * @param hashType - The type of hash : HashType.Pedersen or HashType.Poseidon.\n   * @returns the hash of these data, stored at the base of the tree.\n   * @example\n   * ```typescript\n   * const leaf = merkle.leafHash([\"0x1e6f3\", '100'], HashType.Pedersen);\n   * }\n   * ```\n   */\n  static leafHash(leaf: InputForMerkle, hashType: HashType ): string {\n    if (typeof leaf === 'string') {\n      return hashDataToHex(StarknetMerkleTree.adaptInputItem(leaf),hashType);\n    }\n    const adaptedLeaf = leaf.map(StarknetMerkleTree.adaptInputItem) as string[];\n    return hashDataToHex(adaptedLeaf,hashType);\n  }\n\n  private leafLookup(leaf: InputForMerkle): number {\n    return (\n      this.hashLookup[StarknetMerkleTree.leafHash(leaf,this.hashType)] ??\n      throwError(`'This leaf is not in tree': ${leaf}`)\n    );\n  }\n\n  /**\n   * Returns a proof for the ith value in the tree. Indices refer to\n   * the position of the values in the array from which the tree was constructed.\n   * Also accepts a value instead of an index, but this will be less efficient.\n   * It will fail if the value is not found in the tree.\n   *\n   * @param leaf - the position of construction, or the data contained in a leaf.\n   * @returns the proof, to provide to the smart-contract.\n   * @example\n   * ```typescript\n   * const proof = tree.getProof(3);\n   * const proof = tree.getProof([\"0x43af5\", '100']);\n   * }\n   * ```\n   */\n  getProof(leaf: number | InputForMerkle): string[] {\n    const valueIndex = typeof leaf === 'number' ? leaf : this.leafLookup(leaf);\n    this.validateValue(valueIndex);\n    // rebuild tree index and generate proof\n    const { treeIndex } = this.values[valueIndex]!;\n    const proof: bigint[] = getProof(this.tree, treeIndex);\n    // sanity check proof\n    if (!this.internVerify(this.tree[treeIndex], proof)) {\n      throw new Error('Unable to prove value');\n    }\n    return proof.map(biToHex);\n  }\n\n  /**\n   * Returns a boolean that is `true` when the proof verifies that\n   * the value is contained in the tree.\n   * @remarks\n   * This job is normally made by the smart-contract.\n   * Present here just to be able to check in the DAPP.\n   *\n   * @param leaf - the position of construction, or the data contained in a leaf.\n   * @param proof - proof obtained with {@link getProof}.\n   * @returns verification that the leaf is present in the tree,\n   * without using the tree content.\n   * @example\n   * ```typescript\n   * const result = tree.verify(3, proof);\n   * const result = tree.verify([\"0x34e67d\", '100'], proof);\n   * ```\n   */\n  verify(leaf: number | InputForMerkle, proof: string[]): boolean {\n    const adaptedProof = proof.map(StarknetMerkleTree.adaptInputItem) as string[];\n    return this.internVerify(this.getLeafHash(leaf), adaptedProof.map(BigInt));\n  }\n\n  private internVerify(leafHash: bigint, proof: bigint[]): boolean {\n    const impliedRoot = processProof(leafHash, proof, this.hashType);\n    return impliedRoot === this.tree[0];\n  }\n\n  private checkBounds(array: unknown[], index: number) {\n    if (index < 0 || index >= array.length) {\n      throw new Error('Index out of bounds');\n    }\n  }\n\n  private validateValue(valueIndex: number): bigint {\n    this.checkBounds(this.values, valueIndex);\n    const { value, treeIndex } = this.values[valueIndex];\n    this.checkBounds(this.tree, treeIndex);\n    const leafHash: bigint = hashDataToBigint(value,this.hashType);\n    if (!(leafHash === this.tree[treeIndex])) {\n      throw new Error('Merkle tree does not contain the expected value');\n    }\n    return leafHash;\n  }\n\n  private getLeafHash(leaf: number | InputForMerkle): bigint {\n    if (typeof leaf === 'number') {\n      return this.validateValue(leaf);\n    }\n    if (typeof leaf === 'string') {\n      return hashDataToBigint(StarknetMerkleTree.adaptInputItem(leaf),this.hashType);\n    }\n    const adaptedLeaf = leaf.map(StarknetMerkleTree.adaptInputItem) as string[];\n    return hashDataToBigint(adaptedLeaf,this.hashType);\n  }\n}\n"],"mappings":"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","names":["HashType"]}